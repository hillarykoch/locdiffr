---
title: "sgp"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sgp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message = FALSE, message = FALSE, warning = FALSE}
library(sgp)
```

# In progress...

We will run a preliminary analysis with some toy Hi-C data. There are two replicates each from two conditions. If you have more replicates, or differing numbers of replicates from each condition, that's okay. The package will automatically select which replicates to retain based on sequencing depth.

To begin the analysis, you need file paths to all of the data, split into two groups. The data should be in the following tab-delimited format:

| Loc1 | Loc2   | Counts |
|------|--------|--------|
| 0    | 0      | 100    |
| 0    | 50000  | 88     |
| 0    | 100000 | 40     |

Here, Loc1 is the start of the first bin, Loc2 the start of the second bin, and counts indicating the read counts for the interactions between those 2 bins. The value in Loc1 should always be less than or equal to the value in Loc2.

Let's prepare the data pre-loaded into this package. We can see that there are 4 datasets -- two from a knockout group and two from a parent group. These data are already in the correct format.

```{r}
# locate the data
all_data <- list.files(system.file("extdata", package = "sgp"))
print(all_data)
```


Once we have defined file paths to two groups, the rest of the analysis is straightforward and proceeds as follows:

```{r, cache = TRUE, message = FALSE, warning = FALSE, results = "hide"}
# Define paths to data from 2 conditions
ko_data <-
    system.file("extdata", all_data[grepl(pattern = "KO", x = all_data)], package = "sgp")
parent_data <-
    system.file("extdata", all_data[grepl(pattern = "parent", x = all_data)], package = "sgp")

# Compute the SCC scan statistics
run_scc_scan(
    infiles1 = ko_data,
    infiles2 = parent_data,
    outpath = "../inst/extdata/output/z.rds",
    resolution = 40000,
    winsizes = c(20, 30),
    parallel = FALSE,
    offset = TRUE
)

# Fit the nearest-neighbor Gaussian process model via MCMC
fit_nngp(infile = "../inst/extdata/output/z.rds", outpath = "../inst/extdata/output/fit.rds", num_neighbors = 5, iters = 250, parallel = FALSE)

# Use posterior samples to make new draws from the nearest-neighbor Gaussian process, for hypothesis testing
sample_new_nngps(scc_scan_file = "../inst/extdata/output/z.rds", mcmc_fit_file = "../inst/extdata/output/fit.rds", outpath = "../inst/extdata/output/pred.rds", stationary_iterations = 151:250, parallel = FALSE)

```

Results are used to test whether or not a region contains significantly differential interactions. To test, we need to compute $\theta^b(s_w):=\text{I}\big[Z^{b}(s_w) < \mu^b(s_w)\big]$, the indicator that the nearest-neighbor Gaussian process sampled at iteration $b$ at location $s_w$ is less than the mean process at iteration $b$ at the same location. To compute $\theta^b(s_w)$ for all locations $s_w, \, w\in\{1,\ldots W\}$ and all iterations $b, \, b \in \{1,\ldots,B\}$, we provide the function `compute_thetas`. 

```{r}
thetas <-
    compute_thetas(
    mcmc_fit_file =  "../inst/extdata/output/fit.rds",
    sampled_nngps_file = "../inst/extdata/output/pred.rds",
    outpath = "../inst/extdata/output/thetas.rds"
    )
```

Output from `compute_thetas` is used to test for significantly differential regions based on either the weighted false discovery rate or weighted false discovery exceedance criteria:

```{r}
# Compute rejections based on weighted false discovery rate
test_by_wFDR(
    scc_scan_file = "../inst/extdata/output/z.rds",
    thetas_file = "../inst/extdata/output/thetas.rds",
    outpath = "../inst/extdata/output/wfdr.rds",
    alpha = 0.2
    )

# Compute rejections based on weighted false discovery exceedence
test_by_wFDX(
    scc_scan_file = "../inst/extdata/output/z.rds",
    thetas_file = "../inst/extdata/output/thetas.rds",
    outpath = "../inst/extdata/output/wfdx.rds",
    alpha = 0.2,
    beta = 0.2
    )

```

You can easily view the output of the transformed SCC scan, verify that the model fitting is proceeding as expected, and check rejection locations with `plot_rejections_along_process`. In the below plot, z1 and z2 are the observed data. z_star is the average over all of the newly sampled nearest-neighbor Gaussian processes, which we expect to typically take values which are pointwise averages of the observed processes. The mean function is the average mean function across all MCMC iterations. Rejections based on the wFDR and wFDX criteria are marked along the process.

```{r, fig.width = 6, fig.height = 6}
p <- plot_rejections_along_process(scc_scan_file = "../inst/extdata/output/z.rds",
             mcmc_fit_file =  "../inst/extdata/output/fit.rds",
             sampled_nngps_file = "../inst/extdata/output/pred.rds",
             rejection_files = c("../inst/extdata/output/wfdr.rds", "../inst/extdata/output/wfdx.rds"),
             rejection_names = c("wFDR", "wFDX"))
cowplot::plot_grid(plotlist = p, nrow = 2, ncol = 1)
```


